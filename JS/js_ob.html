<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>JS.Объекты</title>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
	<link rel="stylesheet" type="text/css" href="css/main.css"> 
	<script type="text/javascript" src="http://code.jquery.com/jquery-latest.js"></script>
	<script type="text/javascript" src="js/main.js"></script>
    												<!--скрипт определения метонахождения-->
    <script type="text/javascript">$(function () {  
    $('.menu a').each(function () { 
        var location = window.location.href; 
        var link = this.href;  
        if(location == link) { 
            $(this).addClass('mainmenu_a');
            $(this).addClass('col');
            $(this).removeClass('mainmenu_n');
            $(this).removeClass('col-lg-6');
        }
        });
    });
    </script>
</head>
<body style=" background: #FFEB73">
	<div class="container" > 
			<div class="row" style="background: #FFBF00; border: solid;">
				<div class="col col-12">
				<h1 style="text-align: center;">Краткий справочник JS</h3>
				<p style="text-align: right;">Языки/JS/Введение</p> <!--https://bootstrap-4.ru/docs/4.4/components/breadcrumb/-->
				</div>
			</div>
																					<!--верхние кнопки -->
			<div class="row" style="background: #FFBF00; border-bottom: dotted; border-right: dotted; border-left: dotted">
										
									<div class = "col col-12" style="text-align: center; margin: 1% ">
									<a href="../index.html"><button class="btn btn-dark">Вернуться на главную страницу</button></a>
								</div>
			</div>

		<div class="row " style="min-height: 750px ">

																					<!--Меню -загладка -->
			<div class="col col-lg-1 menu">
										<div class="row justify-content-end" style="height: 150px; ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_start.html">
													<div class="mainmenutext">Введение</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 150px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_main.html" >
												<div class="mainmenutext">Основы</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 170px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_fun.html">
												<div class="mainmenutext">Фнукции</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 150px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_ob.html">
												<div class="mainmenutext">Объект</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 150px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="sql_1_table.html">
												<div class="mainmenutext">Анимация</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 170px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_work.html">
												<div class="mainmenutext">Тренеровка</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 170px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_must_know.html">
												<div class="mainmenutext">Особенности</div>
											</a>
										</div>
										<div class="row justify-content-end" style="height: 170px ">
											<a class="col-lg-6 mainmenu_n rounded-left" href="js_something.html">
												<div class="mainmenutext">Другое</div>
											</a>
										</div>
			</div>
																					<!--Меню -загладка -->
	

			<div class="col col-lg-11" >
				<div class="row" style="height: 100%; border: ridge;">
							<div id="sec_menu" class="col col-3" style="background: #FAEEDD; border-right: 1px solid" >
								<p style="text-align: center;color: blue; font-size: 18px ">Структура раздела</p>
								<p><a style="color: blue" href="#Объекты">Объекты</a></p>
								<ul>
									<p>
										<li><a style="color: blue" href="#Литералы">Литералы</a></li>
										<li><a style="color: blue" href="#Обращение">Обращение</a></li>
										<li><a style="color: blue" href="#Добавление/Удаление свойств">Добавление/Удаление свойств</a></li>
										<li><a style="color: blue" href="#Обращение к свойствам из нескольких слов">Обращение к свойствам из нескольких слов</a></li>
										<li><a style="color: blue" href="#Вычисляемые свойства">Вычисляемые свойства</a></li>
										<li><a style="color: blue" href="#Свойство из переменной">Свойство из переменной</a></li>
										<li><a style="color: blue" href="#Проверка существования свойств">Проверка существования свойств</a></li>
										<li><a style="color: blue" href="#Проверка циклом for...in">Проверка циклом for...in</a></li>
										<li><a style="color: blue" href="#Сортировка полей в объектах">Сортировка полей в объектах</a></li>
										<li><a style="color: blue" href="#Копирование по ссылке">Копирование по ссылке</a></li>
										<li><a style="color: blue" href="#Сравнение объектов">Сравнение объектов</a></li>
										<li><a style="color: blue" href="#Объекты-константы">Объекты-константы</a></li>
										<li><a style="color: blue" href="#Копирование и объединение объектов">Копирование и объединение объектов</a></li>
										<li><a style="color: blue" href="#Функция-конструктор">Функция-конструктор</a></li>
										<li><a style="color: blue" href="#Object.keys, values, entries">Object.keys, values, entries</a></li>
										<li><a style="color: blue" href="#Деструктурирующее присваивание">Деструктурирующее присваивание</a></li>
										<li><a style="color: blue" href="#Дата и время">Дата и время</a></li>
									</p>
								</ul>
								<p><a style="color: blue" href="#Массив">Массив</a></p>
								<p><a style="color: blue" href="#Map и Set">Map и Set</a></p>

								
							</div>
							<div  style="background: #FAEEDD;; width: 35px;  position: relative; display: inline-block;">
									<img id="hide" src="img/arrow-bar-left.svg" alt="" style="width: 100%;" onclick="(document.getElementById('sec_menu').style.display='none', document.getElementById('hide').style.display='none', document.getElementById('block').style.display='block' )"></img>
									<img id="block" src="img/arrow-bar-right.svg" alt="" style="width: 100%; display: none;" onclick="(document.getElementById('sec_menu').style.display='block', document.getElementById('hide').style.display='block', document.getElementById('block').style.display='none' )"></img>
							</div>

																													<!--Начало главного блока-->
					<div class="col" style="background: #FAEEDD; ">
						<p>
							<h1><a id="Объекты" name="Объекты">Объекты </a></h1>
							<p>Объекты же используются для хранения коллекций различных значений и более сложных сущностей. (массив?) Он состадется 2 способами:</p>
							<div class="code">
								<p>
									let user = new Object(); // синтаксис "конструктор объекта"
									<br>let user = {};  // синтаксис "литерал объекта"
								</p>
							</div>
							<p>Очень важно понять, {} - объект, user - сслыка на объект, его название.</p>
							<h4>Литералы</h4>
							<p>При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение». Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки. Значение может быть любого типа. Последнее свойство объекта может заканчиваться запятой</p>
							<div class="code">
								<p>
									let user = {     // объект
  									<br>&nbsp;&nbsp;name: "John",  // под ключом "name" хранится значение "John"
  									<br>&nbsp;&nbsp;age: 30        // под ключом "age" хранится значение 30
									<br>};
									<br>//Что то типо 
									<br>//Свойство(поле): значение
								</p>
							</div>
							<h4><a id="Обращение" name="Обращение">Обращение</h4>
							<p>Для обращения к свойствам используется запись «через точку»</p>
							<div class="code">
								<p>
									// получаем свойства объекта:
									<br>alert( user.name ); // John
									<br>alert( user.age ); // 30
								</p>
							</div>
							<h4><a id="Добавление/Удаление свойств" name="Добавление/Удаление свойств">Добавление/Удаление свойств</h4>
							<p>Для удаления свойств используется оператор delete</p>
							<div class="code">
								<p>
									user.isAdmin = true;
									<br>delete user.age;
								</p>
							</div>
							<h4><a id="Обращение к свойствам из нескольких слов" name="Обращение к свойствам из нескольких слов">Обращение к свойствам из нескольких слов</h4>
							<p>Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает. Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства</p>
							<div class="code">
								<p>
									let user = {};

									<br>// присваивание значения свойству
									<br>user["likes birds"] = true;

									<br>// получение значения свойства
									<br>alert(user["likes birds"]); // true

									<br>// удаление свойства
									<br>delete user["likes birds"];
								</p>
							</div>
							<p>Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:</p>
							<div class="code">
								<p>
									let key = "likes birds";

									<br>// то же самое, что и user["likes birds"] = true;
									<br>user[key] = true;
								</p>
							</div>
							<h4><a id="Вычисляемые свойства" name="Вычисляемые свойства">Вычисляемые свойства</h4>
							<p>Иногда имя параметру можно задавать из вне, а в объекте ссылаться на эту переменную из вне. Выглядит это так:</p>
							<div class="code">
								<p>
									let fruit = prompt("Какой фрукт купить?", "apple"); // тут мы задаем переменную fruit
									<br>let bag = {};//создаем объект

									<br>// имя свойства будет взято из переменной fruit
									<br>bag[fruit] = 5; 
								</p>
							</div>
							<p>Так же можно сделать комбо, например задать так:</p>
							<div class="code">
								<p>
									[fruit + 'Computers']: 5 // bag.appleComputers = 5
								</p>
							</div>
							<p>Подведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то более сложное, то мы используем квадратные скобки.</p>
							<h4><a id="Свойство из переменной" name="Свойство из переменной">Свойство из переменной</h4>
							<p>Если параметр свойства равен названию свойства, можно сокрощать так:</p>
							<div class="code">
								<p>
									let user = {
  									<br>&nbsp;&nbsp;name,  // тоже самое, что и name:name
  									<br>&nbsp;&nbsp;age: 30
									<br>};
								</p>
							</div>
							<h4><a id="Проверка существования свойств" name="Проверка существования свойств">Проверка существования свойств</h4>
							<p>Проверка, которая вернет нам true или false, выглядит так: </p>
							<div class="code">
								<p>
									"key" in object //свойство В объекте
								</p>
							</div>
							<p>Например:</p>
							<div class="code">
								<p>
									let user = { name: "John", age: 30 };

									<br>alert( "age" in user ); // true, user.age существует
									<br>alert( "blabla" in user ); // false, user.blabla не существует
								</p>
							</div>
							<p>Стоит отметить, что проверяемое свойство ставится в кавычки, только если это не переменная, которой присовенно имя св-ва. Например:</p>
							<div class="code">
								<p>
									let user = { age: 30 };

									<br>let key = "age";
									<br>alert( key in user ); // true, имя свойства было взято из переменной key
								</p>
							</div>
							<p>Стоит отметить, что так же проверить можно вот так:</p>
							<div class="code">
								<p>
									let user = {};

								<br>alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
								</p>
							</div>
							<p>Мне больше нравится пока что IN.</p>
							<h4><a id="Проверка циклом for...in" name="Проверка циклом for...in">Проверка циклом for...in</h4>
							<p>Если мы хотим посмотреть все свойства и значения объекта, необходимо исполоьзовать цикл</p>
							<div class="code">
								<p>
									let user = {
  									<br>&nbsp;&nbsp;name: "John",
  									<br>&nbsp;&nbsp;age: 30,
  									<br>&nbsp;&nbsp;isAdmin: true
									<br>};

									<br>for (let key in user) {
  									<br>&nbsp;&nbsp;// ключи
  									<br>&nbsp;&nbsp;alert( key );  // name, age, isAdmin
  									<br>&nbsp;&nbsp;// значения ключей
 									<br>&nbsp;&nbsp;alert( user[key] ); // John, 30, true
									<br>}
								</p>
							</div>
							<p>Шаблон:</p>
							<div class="code">
								<p>
									for (key in object) {
  									<br>// тело цикла выполняется для каждого свойства объекта
									<br>}		
								</p>
							</div>
							<h4><a id="Сортировка полей в объектах" name="Сортировка полей в объектах">Сортировка полей в объектах</h4>
							<p>Все что может быть преобразовано в целые числа - идет по порядку возрастания. Все остальное по мередобавления. Описано вот <a href="https://learn.javascript.ru/object#uporyadochenie-svoystv-obekta">тут</a></p>
							<h4><a id="Копирование по ссылке" name="Копирование по ссылке">Копирование по ссылке</h4>
							<p>ОЧЕНЬ ВАЖНО ПОНЯТЬ! <a href="https://learn.javascript.ru/object#kopirovanie-po-ssylke">Тут</a> описано по одному,я расталкую для себя по другому. По сути, объект это набор ссылок на поля, а не сами поля. Поля хранятся где то. Картинка это хорошо поясняет. В объектах user и admin мы храним ссылки на поле Name
								<br> <img src="img\copyOb.png">
								<br> То есть по ссылке мы можем менять и вызывать значение, то есть использовать и admin и user. Рассмотрим пример, это очень важно разобраться.
							</p>
							<div class="code">
								<p>
									let user = { 
									<br>name: 'John',
									<br>age: '20'
									<br>};

									<br>let admin = user; // мы скопировали самы ссылки, еще одного name и age не появились
									<br>alert(user.name + admin.age);
									<br>admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
									<br>user.age = '50' // изменено по ссылке из переменной "user"

									<br>alert(user.name + admin.age); // 'Pete', изменения видны по ссылке из переменной "user"
								</p>
							</div>
							<button type="button" class="btn btn-outline-primary" onclick="copyOb()">Запуск</button>
							<h4><a id="Сравнение объектов" name="Сравнение объектов">Сравнение объектов</h4>
							<p>Сравниваются опять же значения ссылок. Операторы равенства == и строгого равенства === для объектов работают одинаково.Д ва объекта равны только в том случае, если это один и тот же объект(то есть второй объект создан как КОПИЯ первого).Поэксперементируем отдельно в разделе Тренировка.</p>
							<h4><a id="Объекты-константы" name="Объекты-константы">Объекты-константы</h4>
							<p>Как ни странно, такие объекты можно менять. <b>НО</b> конкретно мы можем менять <b>ЧТО</b> содержит ссылка или объект, а сами ссылки менять не можем <span style="color: red">(что как то странно, спросить бы у опытных)</span>. Например, так у нас все получится:</p>
							<div class="code">
								<p>
									function const_ob_1() {
    									<br>&nbsp;&nbsp;const user = {
        									<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Dashka"
    									<br>&nbsp;&nbsp;}
    									<br>
    									<br>&nbsp;&nbsp;user.name = 'Daria'
    									<br>&nbsp;&nbsp;user.age = 26;
    									<br>
    									<br>&nbsp;&nbsp;alert(user.name + ' ' + 'возраст' + ' ' + user.age );
									<br>}
								</p>
							</div>
							<button type="button" class="btn btn-outline-primary" onclick="const_ob_1()">Запуск</button>
							<p>А вот так уже не сработает. Если мы посмотрим в консоли, ошибка будет как раз в тот момент, когда мы пытаемся изменить <b>объект</b>, а не ссылки</p>
							<div class="code">
								<p>
									function const_ob_2() {
    									<br>&nbsp;&nbsp;const user = {
        									<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Dashka"
    									<br>&nbsp;&nbsp;}
    									<br>&nbsp;&nbsp;// Дальше ошибка
    									<br>&nbsp;&nbsp;const user = {
        									<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Daria"
    									<br>&nbsp;&nbsp;}
    									<br>
    									<br>&nbsp;&nbsp;alert(user.name);
									<br>}									
								</p>
							</div>
							<button type="button" class="btn btn-outline-primary" onclick="const_ob_2()">Запуск</button>
							<h4><a id="Копирование и объединение объектов" name="Копирование и объединение объектов">Копирование и объединение объектов</h4>
							<p>Если нам надо скопировать объект, создавая новвые ссылки, мы можем использовать 2 метода. <br> 1 Метод:</p>
							<div class="code">
								<p>
									function copy_ob_1() {
    									<br>&nbsp;&nbsp;let user = {
        									<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "John",
        									<br>&nbsp;&nbsp;&nbsp;&nbsp;age: 30
    									<br>&nbsp;&nbsp;};
    									<br>
    									<br>&nbsp;&nbsp;let clone = {}; // новый пустой объект
    									<br>
    									<br>&nbsp;&nbsp;// скопируем все свойства user в него
    									<br>&nbsp;&nbsp;for (let key in user) {
    									<br>&nbsp;&nbsp;clone[key] = user[key];
    									<br>&nbsp;&nbsp;}
    									<br>
    									<br>&nbsp;&nbsp;// теперь в переменной clone находится абсолютно независимый клон объекта.
    									<br>&nbsp;&nbsp;clone.name = "Pete";
    									<br>&nbsp;&nbsp;clone.age = 25 // изменим в нём данные
    									<br>
    									<br>&nbsp;&nbsp;alert('Первый объект:' + ' ' +  user.name + ' ' + user.age ); // в оригинальном объекте значение  осталось прежним 
    									<br>&nbsp;&nbsp;alert('Второй объект:' + ' ' + clone.name + ' ' + clone.age);
									<br>}
								</p>
							</div>
							<button type="button" class="btn btn-outline-primary" onclick="copy_ob_1()">Запуск</button>
							<p>2 метод. Используется метод  Object.assign:</p>
							<div class="code">
								<p>
									Object.assign(dest, [src1, src2, src3...])
								</p>
							</div>
							<p>Аргументы dest, и src1, ..., srcN (может быть столько, сколько нужно) являются объектами. [src1, src2, src3...] копируется в dest. Если есть одинаковые ссылки, то они будут перезаписываться. <br>Копирование</p>
							<div class="code">
								<p>
									let user = {
  									<br>&nbsp;&nbsp;name: "John",
  									<br>&nbsp;&nbsp;age: 30
									<br>};
									<br>
									<br>let clone = Object.assign({}, user);
								</p>
							</div>
							<p>Объединение</p>
							<div class="code">
								<p>
									let user = { name: "John" };
									<br>
									<br>let permissions1 = { canView: true };
									<br>let permissions2 = { canEdit: true };
									<br>
									<br>// копируем все свойства из permissions1 и permissions2 в user
									<br>Object.assign(user, permissions1, permissions2);
									<br>
									<br>// now user = { name: "John", canView: true, canEdit: true }
								</p>
							</div>
							<p>Следует понимать, что копируются ссылки. То есть если в объекте 1 есть объект 1.1, то копируя объект 1 в объект 2, копируется ссылка на объект 1.1. То есть обхект 2 будет иметь тот же объект 1.1. То есть и объект 1 и объект 2 будут ссылаться на 1 и тот же объект. Можно посмотреть <a href="https://learn.javascript.ru/object#klonirovanie-i-obedinenie-obektov-object-assign">here</a>, в сама низу</p>
							<h4><a id="Функция-конструктор" name="Функция-конструктор">Функция-конструктор</a></h4>
							<p>Функции-конструкторы являются обычными функциями. Но есть два соглашения:
								<ul>
									<li>Имя функции-конструктора должно начинаться с большой буквы.</li>
									<li>Функция-конструктор должна вызываться при помощи оператора "new".</li>
								</ul>
								<br>Пример:
							</p>
							<div class="code">
								<p>
									function User(name) {
  									<br>&nbsp;&nbsp;this.name = name;
  									<br>&nbsp;&nbsp;this.isAdmin = false;
									<br>}
									<br>
									<br>let user = new User("Вася");
									<br>
									<br>alert(user.name); // Вася
									<br>alert(user.isAdmin); // false
								</p>
							</div>
							<h4><a id="Object.keys, values, entries" name="Object.keys, values, entries">Object.keys, values, entries</a></h4>
							<p>(<a href="https://learn.javascript.ru/keys-values-entries">подробности</a>)Для простых объектов доступны следующие методы:
								<ul>
									<li>Object.keys(obj) – возвращает массив ключей.</li>
									<li>Object.values(obj) – возвращает массив значений.</li>
									<li>Object.entries(obj) – возвращает массив пар [ключ, значение].</li>
								</ul>
							</p>
							<h4><a id="Деструктурирующее присваивание" name="Деструктурирующее присваивание">Деструктурирующее присваивание</a></h4>
							<p>(<a href="https://learn.javascript.ru/destructuring-assignment">подробности</a>)Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.
								<br>Полный синтаксис для объекта:
								<li>let {prop : varName = default, ...rest} = object</li>
								<br>Свойства, которые не были упомянуты, копируются в объект rest.
								<br>Полный синтаксис для массива:
								<li>let [item1 = default, item2, ...rest] = array</li>
								<br>Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.
								<br>Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.
							</p>			
							<h4><a id="Дата и время" name="Дата и время">Дата и время</a></h4>	
							<p>Дата и время в JavaScript представлены объектом Date. Нельзя создать «только дату» или «только время»: объекты Date всегда содержат и то, и другое.
								<br>Счёт месяцев начинается с нуля (да, январь – это нулевой месяц).
								<br>Дни недели в getDay() также отсчитываются с нуля, что соответствует воскресенью.
								<br>Объект Date самостоятельно корректируется при введении значений, выходящих за рамки допустимых. Это полезно для сложения/вычитания дней/месяцев/недель.
								<br>Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект Date становится таймстампом.
								<br>Используйте Date.now() для быстрого получения текущего времени в формате таймстампа.
								<br>Учтите, что, в отличие от некоторых других систем, в JavaScript таймстамп в миллисекундах, а не в секундах.
							</p>	
							<h4 style="text-align: center;"><a href="js_ob_arr.html" id="Массив" name="Массив">Массив</a> рассмотрим отдельно, так как тема большая, но коротко так:</h4>
							<p>Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.
								<br>Объявление:
								<br>// квадратные скобки (обычно)
								<br>let arr = [item1, item2...];
								<br>
								<br>// new Array (очень редко)
								<br>let arr = new Array(item1, item2...);
								<br>Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.
								<br>Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
								<br>Если мы уменьшаем length вручную, массив укорачивается.
								<br>Мы можем использовать массив как двустороннюю очередь, используя следующие операции:
								<ul>
									<li>push(...items)добавляет items в конец массива.</li>
									<li>pop() удаляет элемент в конце массива и возвращает его.</li>
									<li>shift() удаляет элемент в начале массива и возвращает его.</li>
									<li>unshift(...items) добавляет items в начало массива.</li>
								</ul>
								Чтобы пройтись по элементам массива:
								<ul>
									<li>for (let i=0; i < arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.</li>
									<li>for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).</li>
									<li>for (let i in arr) – никогда не используйте для массивов!</li>
								</ul>
							</p>
							<h4 style="text-align: center;"><a  id="Map и Set" name="Map и Set">Map и Set</a><br>Подробности <a href="https://learn.javascript.ru/map-set#map">тут</a> и WeakMap и WeakSet <a href="https://learn.javascript.ru/weakmap-weakset">тут</a>,а коротко так:</h4>
							<p>
								<b>Map</b> – коллекция пар ключ-значение.
								<br>Методы и свойства:
								<ul>
									<li>new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.</li>
									<li>map.set(key, value) – записывает по ключу key значение value.</li>
									<li>map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.</li>
									<li>map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.</li>
									<li>map.delete(key) – удаляет элемент по ключу key.</li>
									<li>map.clear() – очищает коллекцию от всех элементов.</li>
									<li>map.size – возвращает текущее количество элементов.</li>
								</ul>
								Отличия от обычного объекта Object:
								<ul>
									<li>Что угодно может быть ключом, в том числе и объекты.</li>
									<li>Есть дополнительные методы, свойство size.</li>
								</ul>
								<b>Set</b> – коллекция уникальных значений, так называемое «множество».
								<br>Методы и свойства:
								<ul>
									<li>new Set([iterable]) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.</li>
									<li>set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.</li>
									<li>set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.</li>
									<li>set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.</li>
									<li>set.clear() – удаляет все имеющиеся значения.</li>
									<li>set.size – возвращает количество элементов в множестве.</li>
								</ul>
								Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
								<br><b>WeakMap</b> -  это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями. <br>В WeakMap присутствуют только следующие методы:
								<ul>
									<li>weakMap.get(key)</li>
									<li>weakMap.set(key, value)</li>
									<li>weakMap.delete(key)</li>
									<li>weakMap.has(key)</li>
								</ul>
								<b>WeakSet</b> - это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.	
								<h4 style="text-align: center;"><a href="js_ob_arr.html" id="Map и Set" name="Map и Set"></a></h4>							
							</p>

						</p>
					</div>
				</div>
			</div>
		</div>

		<div class="row">
			<div class = "col-12" style="background: #FFBF00; border: dotted;">
			<p style="text-align: center;">ЭТО ДНИЩЕ САЙТА </p>
			</div>
		</div>
		
	</div>
	
</body>
</html>